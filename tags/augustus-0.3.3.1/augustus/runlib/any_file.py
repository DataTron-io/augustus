
"""Generic file resource access wrapper

Provides run-time access to files or file-like resources via
a single access object.  Files may be in the local filesystem,
in a database, or (in the future) generated by shell call
(which, for example, may get the file from a remote machine or
may generate the file by running some program).

Files are requested by their base filename (no path element),
and will be located using a viewpath-like mechanism that
searches each registered location in turn.

"""

__copyright__ = """
Copyright (C) 2005-2006  Open Data ("Open Data" refers to
one or more of the following companies: Open Data Partners LLC,
Open Data Research LLC, or Open Data Capital LLC.)

This file is part of Augustus.

Augustus is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
"""


import os
from cStringIO import StringIO

################################################################

class FileResources(object):
  """Access point for file-like resources used by an application.

  This object is initialized with a sequence of search locations,
  which may include file paths and/or database locations.  When
  a file is requested, the locations are searched in turn and the
  first matching instance is chosen.  All files are returned as
  an open file-like object (may be a file handle or a StringIO
  simulation).

  In typical use, instead of:
    
  try:
    boot = open('test/config/bootStrapConfig','rb')
  except:
    boot = open('./config/bootStrapConfig','rb')

  use FileResources as follows:

    resources = FileResources()
    resources.append(PathSearch('.','config','data','pmml'))
    resources.append(DBSearch(MySQLdb,dbargs={'user':'','db':''}, \
                              tbl='files',name_key='mname',data_key='file_content'))
    resources.insert(0,PathSearch('test','config','data','pmml'))
    boot = resources.open('bootStrapConfig')

  An alternate setup example:

    viewpath = [
      PathSearch('test/config'),
      PathSearch('.','config','data','pmml'),
      PathSearch('test/data'),
      DBSearch(MySQLdb,dbargs={'db':'','user':'','passwd':''}, \
               sql='SELECT file_content FROM models WHERE mname=%s')
      PathSearch('test/pmml'),
    ]
    resources = FileResources(viewpath)

  """

  ##############################################################

  def __init__(self,*args):
    self._viewpath = list(args)

  def append(self,arg):
    self._viewpath.append(arg)

  def insert(self,index,arg):
    self._viewpath.insert(index,arg)

  def open(self,filename,mode='rb'):
    for srch in self._viewpath:
      out = srch.open(filename=filename,mode=mode)
      if out is not None:
        return out
    return None

################################################################
# Search objects

################################################################

class PathSearch(object):
  def __init__(self,base,*subdirs):
    self._base = base
    self._subdirs = subdirs
    self._viewpath = vpath = []
    if not len(subdirs):
      # if no subdirs given, then base is included in search
      vpath.append(base)
    else:
      # if subdirs are given, then base is excluded from search
      for subdir in subdirs:
        vpath.append(os.path.join(base,subdir))

  def open(self,filename,mode='rb'):
    for vpath in self._viewpath:
      filepath = os.path.join(vpath,filename)
      try:
        out = open(filepath,mode)
      except IOError:
        continue
      return out
    return None

################################

class DBSearch(object):
  def __init__(self,dbfactory,dbargs={},sql=None,tbl='files',namekey='filename',datakey='file_content'):
    # dbfactory can be a module, such as MySQLdb, or
    # it may be an instance of any_db.ConnectFactory()
    self._dbfactory = dbfactory
    self._dbargs = dbargs
    self._tbl = tbl
    self._namekey = namekey
    self._datakey = datakey
    if sql is None:
      sql = 'SELECT %s FROM %s WHERE %s=%%s' % (datakey,tbl,namekey)
    self._sql = sql

  def open(self,filename,mode='rb'):
    db = self._dbfactory.connect(**self._dbargs)
    cur = db.cursor()
    cur.execute(self._sql,filename)
    try:
      result = cur.fetchone()
    except:
      result = None
    cur.close()
    db.close()
    if result is None:
      return None
    return StringIO(result[0])

#################################################################
# vim:sw=2:sts=2:expandtab:shiftround
